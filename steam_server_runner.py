import json
import os
import time
import logging
import subprocess
from datetime import datetime, timezone
from steam_server_time_manager import SteamServerTimeManager
import re
import argparse

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='steam_server_runner.log',
    filemode='a'
)

def get_utc_now():
    return datetime.now(timezone.utc)

class SteamServerRunner:
    """
    Manages the process of running AHK script against Steam servers
    in priority order based on time slots 
    """
    
    def __init__(self, 
                 ahk_script_path="cs2_automation.ahk",
                 server_list_path="preferred_servers.txt",
                 all_servers_path="all_servers.json",
                 server_blocklist_path="steam_servers.conf"):
        """
        Initialize the Steam Server Runner
        
        Args:
            ahk_script_path: Path to the AHK script to run
            server_list_path: Path to the file containing preferred servers
            all_servers_path: Path to the JSON file with all server information
            server_blocklist_path: Path to the firewall blocklist file
        """
        self.ahk_script_path = ahk_script_path
        self.server_list_path = server_list_path
        self.all_servers_path = all_servers_path
        self.server_blocklist_path = server_blocklist_path
        
        # Initialize the server time manager
        self.server_manager = SteamServerTimeManager(
            timezone_map_file="server_timezone_map.json",
            preferred_servers_file=server_list_path
        )
        
        # Load all server info
        self.all_servers = self.load_all_servers()
        
        # Internal state
        self.current_server = None
        self.server_start_time = None
    
    def load_all_servers(self):
        """Load the complete list of Steam servers"""
        try:
            if os.path.exists(self.all_servers_path):
                with open(self.all_servers_path, 'r') as f:
                    return json.load(f)
            else:
                logging.error(f"All servers file not found: {self.all_servers_path}")
                return {}
        except Exception as e:
            logging.error(f"Error loading all servers: {str(e)}")
            return {}
    
    def load_preferred_servers(self):
        """Load the list of preferred servers"""
        preferred_servers = []
        
        try:
            if os.path.exists(self.server_list_path):
                with open(self.server_list_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        # Skip empty lines and comments
                        if line and not line.startswith('#'):
                            preferred_servers.append(line)
                logging.info(f"Loaded {len(preferred_servers)} preferred servers")
            else:
                logging.warning(f"Preferred servers file not found: {self.server_list_path}")
        except Exception as e:
            logging.error(f"Error loading preferred servers: {str(e)}")
        
        return preferred_servers
    
    def update_server_blocklist(self, server_to_unblock=None):
        """
        Update the server blocklist file, unblocking only one server
        
        Args:
            server_to_unblock: Name of the server to unblock (all others will be blocked)
            
        Returns:
            bool: Success/failure
        """
        try:
            # Skip if all_servers is empty
            if not self.all_servers:
                logging.error("Cannot update blocklist: all_servers is empty")
                return False
            
            # Create the blocklist content
            blocklist_content = "# Steam servers blocklist - Generated by SteamServerRunner\n"
            blocklist_content += f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            blocklist_content += f"# All servers blocked except: {server_to_unblock}\n\n"
            
            # Add all servers to the blocklist except the one to unblock
            for server_name, ip_list in self.all_servers.items():
                # Skip the server we want to unblock
                if server_name == server_to_unblock:
                    blocklist_content += f"# UNBLOCKED: {server_name} - {ip_list}\n"
                    continue
                
                # Add IPs to blocklist
                for ip in ip_list.split(","):
                    blocklist_content += f"{ip}\n"
            
            # Write the blocklist file
            with open(self.server_blocklist_path, 'w') as f:
                f.write(blocklist_content)
            
            logging.info(f"Updated server blocklist, unblocked: {server_to_unblock}")
            return True
        except Exception as e:
            logging.error(f"Error updating server blocklist: {str(e)}")
            return False
    
    def run_ahk_script(self):
        """
        Run the AHK script and capture its output
        
        Returns:
            tuple: (success, profiles_harvested)
        """
        logging.info(f"Starting AHK script: {self.ahk_script_path}")
        
        try:
            # Command to run AHK script
            ahk_exe = "C:\\Program Files\\AutoHotkey\\v2\\AutoHotkey.exe"
            cmd = [ahk_exe, self.ahk_script_path]
            
            # Run the process and capture output
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # Wait for completion
            stdout, stderr = process.communicate()
            
            # Convert output to string
            stdout_str = stdout.decode('utf-8', errors='ignore')
            stderr_str = stderr.decode('utf-8', errors='ignore')
            
            # Log process output
            if stdout_str:
                logging.info(f"AHK script output: {stdout_str[:200]}...")  # Log first 200 chars
            if stderr_str:
                logging.error(f"AHK script error: {stderr_str}")
            
            # Parse output for harvest results
            profiles_harvested = self.parse_harvest_results(stdout_str)
            
            # Check return code
            if process.returncode == 0:
                logging.info(f"AHK script completed successfully, harvested {profiles_harvested} profiles")
                return True, profiles_harvested
            else:
                logging.error(f"AHK script failed with return code {process.returncode}")
                return False, profiles_harvested
                
        except Exception as e:
            logging.error(f"Error running AHK script: {str(e)}")
            return False, 0
    
    def parse_harvest_results(self, output):
        """
        Parse the output from AHK to extract the number of harvested profiles
        
        Args:
            output: String output from the AHK script
            
        Returns:
            int: Number of harvested profiles
        """
        # Look for a pattern like "HARVEST_RESULT:24" or "Profiles found: 24"
        
        # Try the explicit marker first
        harvest_marker = re.search(r'HARVEST_RESULT:(\d+)', output)
        if harvest_marker:
            return int(harvest_marker.group(1))
        
        # Try alternative patterns
        profiles_pattern = re.search(r'Profiles found: (\d+)', output)
        if profiles_pattern:
            return int(profiles_pattern.group(1))
        
        # Look for any number preceded by "profile" or "profiles"
        profile_count = re.search(r'(\d+) profiles?', output)
        if profile_count:
            return int(profile_count.group(1))
            
        # Default to 0 if no pattern matches
        logging.warning("Could not parse harvest results from AHK output")
        return 0
    
    def run_server(self, server_name):
        """
        Run the AHK script against a specific server
        
        Args:
            server_name: Name of the server to use
            
        Returns:
            tuple: (success, profiles_harvested)
        """
        # Update current server and start time
        self.current_server = server_name
        self.server_start_time = datetime.now()
        
        # Log the server we're about to use
        logging.info(f"Running server: {server_name}")
        
        # Update the blocklist to unblock only this server
        if not self.update_server_blocklist(server_name):
            logging.error(f"Failed to update blocklist for server: {server_name}")
            return False, 0
        
        # Run the AHK script
        success, profiles_harvested = self.run_ahk_script()
        
        # Calculate end time
        end_time = datetime.now()
        
        # Log performance
        self.server_manager.log_server_performance(
            server_name,
            self.server_start_time,
            end_time,
            profiles_harvested
        )
        
        return success, profiles_harvested
    
    def run_server_cycle(self):
        """
        Run through a cycle of preferred servers
        
        Returns:
            bool: Success/failure
        """
        # Check if we need to update the preferred servers list
        self.server_manager.check_and_update_preferred_servers()
        
        # Load the preferred servers
        preferred_servers = self.load_preferred_servers()
        
        if not preferred_servers:
            logging.error("No preferred servers available")
            return False
        
        # Track overall success
        overall_success = True
        total_profiles = 0
        
        # Process each server
        for server_name in preferred_servers:
            # Get current hour before starting
            current_hour = get_utc_now().hour
            
            # Skip if not in all_servers
            if server_name not in self.all_servers:
                logging.warning(f"Server not found in all_servers: {server_name}")
                continue
            
            # Run this server
            success, profiles = self.run_server(server_name)
            total_profiles += profiles
            
            if not success:
                logging.warning(f"Failed to run server: {server_name}")
                overall_success = False
            
            # Check if the hour has changed after processing this server
            new_hour = get_utc_now().hour
            if new_hour != current_hour:
                logging.info(f"Hour changed from {current_hour} to {new_hour}, updating server list")
                self.server_manager.update_preferred_servers_list()
                break  # Exit the loop to start with the new prioritized list
        
        logging.info(f"Completed server cycle, harvested {total_profiles} profiles in total")
        return overall_success
    
    def run_continuous(self):
        """Run continuously, cycling through servers and updating based on time"""
        logging.info("Starting continuous server operation")
        
        cycle_count = 0
        total_profiles = 0
        
        try:
            while True:
                cycle_count += 1
                logging.info(f"Starting server cycle #{cycle_count}")
                
                # Run a cycle of servers
                success = self.run_server_cycle()
                
                if not success:
                    logging.warning(f"Cycle #{cycle_count} encountered some failures")
                
                # Brief pause between cycles
                logging.info(f"Completed cycle #{cycle_count}, pausing before next cycle")
                time.sleep(30)  # 30 second pause
                
        except KeyboardInterrupt:
            logging.info("Received keyboard interrupt, exiting")
        except Exception as e:
            logging.error(f"Error in continuous operation: {str(e)}")
            return False
        
        return True


if __name__ == "__main__":
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Steam Server Runner")
    parser.add_argument("--ahk", default="cs2_automation.ahk", help="Path to AHK script")
    parser.add_argument("--servers", default="preferred_servers.txt", help="Path to preferred servers file")
    parser.add_argument("--allservers", default="all_servers.json", help="Path to all servers JSON file")
    parser.add_argument("--blocklist", default="steam_servers.conf", help="Path to server blocklist file")
    
    args = parser.parse_args()
    
    # Create and run the server runner
    runner = SteamServerRunner(
        ahk_script_path=args.ahk,
        server_list_path=args.servers,
        all_servers_path=args.allservers,
        server_blocklist_path=args.blocklist
    )
    
    # Run continuously
    runner.run_continuous()